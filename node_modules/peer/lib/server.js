var util = require('./util');
var bodyParser = require('body-parser');
var WebSocketServer = require('ws').Server;
var url = require('url');
var cors = require('cors');
var app = exports = module.exports = {};
var fs = require('fs');
var btoa = require('btoa');
var atob = require('atob');

//var userDB = {};
//var userDimsDB = {};
var Swarms = {};
var unfullSwarms = [];
var initialData = {};
var pages = {};
var cssToProcess = [];
var randoms = [];
var randomI = 0;
for (var j=0;j<1e6;j++) {
  randoms[randoms.length]=Math.random();
}


  /** Initialize WebSocket server. */
app._initializeWSS = function(server) {

  var self = this;
  console.log("port:");
  console.log(process.env.PORT);
  console.log("ip:");
  console.log(process.env.IP);
  
  // var interval = setInterval(function() {
  //   var file = fs.createWriteStream('/root/UserDB.txt');
  //   file.on('error', function(err) { //console.log(err); 
  //   });
  //   for (var k in userDB) {
  //       if (userDB.hasOwnProperty(k)) {
  //         file.write(k+","+userDB[k]+ '\n');
  //       }
  //   }
  //   file.end();
  //   var file = fs.createWriteStream('/root/UserDBD.txt');
  //   file.on('error', function(err) { //console.log(err); 
  //   });
  //   for (var k in userDimsDB) {
  //       if (userDimsDB.hasOwnProperty(k)) {
  //         file.write(k+","+userDimsDB[k]+ '\n');
  //       }
  //   }
  //   file.end();
  //   console.log("DB Saved");
  // }, 303000);
  // for(var i = 0;i<defaults.length;i++){
  //   var Sid = "0"+app._generateHash(defaults[i],9);
  //   Swarms[Sid]= {last:[0,0,0,0,0],count:1,update:new Date()};
  //   unfullSwarms[i] = Sid;
  //   //console.log(defaults[i]+":"+unfullSwarms[i]);
  // }
  // var interval3 = setInterval(function() { //check swarm levels every minute
  //   var keyz = Object.keys(Swarms);
  //   for(var i=0;i<keyz.length;i++){
  //     console.log(keyz[i]);
  //   }
  // }, 60000);
  // function buildHeaders(){
  //   var keyz = Object.keys(initialData);
  //   for(var i = 0;i<keyz.length;i++){
  //     if (initialData.hasOwnProperty(keyz[i])){
        
  //       if(keyz[i].indexOf(".html")!=-1&&keyz[i].indexOf("```")==-1){
  //         var page =  atob(initialData[keyz[i]].substring(23,initialData[keyz[i]].length-2));
  //         var endofHead = page.indexOf("</head>");
  //         var requestedPage = keyz[i].replace(/\.[^/.]+$/, "");
  //         var title = keyz[i];
  //         var data = initialData[keyz[i]];
  //         //console.log("replacing headers for:"+keyz[i]+", "+requestedPage);
  //         for(var j = 0;j<keyz.length;j++){
  //           if(i!=j && keyz[j].indexOf(requestedPage)!=-1&&page.indexOf("./"+keyz[j])>=0&&page.indexOf("./"+keyz[j])<endofHead){
  //             console.log("file:"+keyz[j]+", index:"+page.indexOf("./"+keyz[j]));
  //             title +="```"+keyz[j];
  //             data +="```"+initialData[keyz[j]];
  //             delete initialData[keyz[j]];
  //           }
  //         }
  //         if(title.indexOf("```")!=-1){
  //           initialData[title] = data;
  //           delete initialData[keyz[i]];
  //           console.log("combined headers for:"+keyz[i]+" -> "+title);
  //           i=0;
  //         }
  //       }
  //     }
  //   }
  // }
  // function utf8_to_b64(str) {
  //     return btoa(unescape(encodeURIComponent(str)));
  // }
  // function writeToFile(Str,filename){
  //   var file = fs.createWriteStream(filename);
  //   file.on('error', function(err) { //console.log(err); 
  //   });
  //     file.write(Str);
  //   file.end();
  // }
  
  
  // function slicein(p,value){
  //   var endofHead = p.indexOf("</head>");
  //   //console.log("page has a length of:"+p.length+", head is at:"+p.indexOf("</head>")+", value is:"+value);
    
  //   if(p.indexOf(value)==-1||endofHead<0||p.indexOf(value)>=endofHead||typeof(initialData[value])=='undefined'){
  //     //console.log(page.indexOf(value));
  //     return p;
  //   }
  //   console.log("slicing in:"+value);
  //   p = p.substring(0,p.indexOf(value)-3)+initialData[value]+p.substring(p.indexOf(value)+value.length+1);
  //   delete initialData[value];
  //   return p;
  // }
  
  var HTMLfolder = '../../../../HTML/';
  function readDir(dir,first){
    fs.readdir(dir,function(err,files){
        if(err) {
            console.log(err);
            return;
          }
        files.forEach(function(file){
          var toStrip = "";
          var associatedFiles = [];
          var loopbreaker = 1000;
          var start ="";
          var end  = "";
          var extref = "";
            if (fs.statSync(dir + file).isDirectory()) {
              readDir(dir + file + '/');
            }else{
              var rawFile = fs.readFileSync(dir+file);
              //rawFile = rawFile.toString('utf8');
              var readFile = '"data:text/javascript;base64,'+rawFile.toString('base64')+'"';
              
              if(file.indexOf(".jpg") > -1 || file.indexOf("jpeg") > -1 ){
                readFile = '"data:image/jpg;base64,'+rawFile.toString('base64')+'"';
              }
              if(file.indexOf(".png") > -1 ){
                readFile = '"data:image/png;base64,'+rawFile.toString('base64')+'"';
              }
              if(file.indexOf(".gif") > -1 ){
                readFile = '"data:image/gif;base64,'+rawFile.toString('base64')+'"';
              }
              if(file.indexOf(".html") > -1 ||file.indexOf(".php")>-1){
                toStrip = rawFile.toString();
                associatedFiles = [];
                loopbreaker= 1000;
                console.log(file);
                while((toStrip.indexOf(" src=")!=-1||toStrip.indexOf(" href=")!=-1)&&loopbreaker-->0){
                  if(toStrip.indexOf(" src=")!=-1){
                    start = toStrip.indexOf(" src=");
                    end = toStrip.indexOf('"',toStrip.indexOf(" src=")+6);
                    extref = toStrip.substring(start+6,end);
                    if(extref.indexOf("../")==0)extref = extref.substring(3);
                    if(extref.indexOf("?")!=-1)extref = extref.substring(0,extref.indexOf("?"));
                    //console.log("removed:"+extref);
                    if(extref.length>1000)console.log(extref.substring(0,1000));
                    if(extref.indexOf("http://")==-1 && extref.indexOf("https://")==-1 && extref!="#" && extref.indexOf(".html")==-1)associatedFiles[associatedFiles.length]= extref;
                    toStrip = toStrip.substring(0,start)+toStrip.substr(end);
                  }
                  if(toStrip.indexOf(" href=")!=-1){
                    start = toStrip.indexOf(" href=");
                    end = toStrip.indexOf('"',toStrip.indexOf(" href=")+7);
                    extref = toStrip.substring(start+7,end);
                    if(extref.indexOf("../")==0)extref = extref.substring(3);
                    //console.log("removed:"+extref);
                    
                    if(extref.indexOf("http://")==-1 && extref.indexOf("https://")==-1 && extref!="#" && extref.indexOf(".html")==-1)associatedFiles[associatedFiles.length]= extref;
                    toStrip = toStrip.substring(0,start)+toStrip.substr(end);
                  }
                  //console.log(associatedFiles.length);
                }
                if(loopbreaker == 0)console.log("loop broken");
                pages[dir.substring(17)+file] = associatedFiles;
                console.log("Page ex complete, removed:"+associatedFiles.length);
                readFile = '"data:text/html;base64,'+btoa(unescape(encodeURIComponent(rawFile)))+'"';
              }
              if(file.indexOf(".css") > -1 ){
                toStrip = rawFile.toString();
                if(toStrip.indexOf("url(")!=-1){
                  cssToProcess[cssToProcess.length]=dir.substring(17)+file;
                  readFile = rawFile.toString();
                  console.log("saving css for later");
                }else{
                  readFile = '"data:text/css;base64,'+btoa(unescape(encodeURIComponent(rawFile)))+'"';
                }
              }
              if(file.indexOf(".js") > -1 ){
                readFile = '"data:text/javascript;base64,'+btoa(unescape(encodeURIComponent(rawFile)))+'"';
                //console.log("js encoded");
              }
              if(file.indexOf(".svg") > -1 ){
                readFile = '"data:image/svg+xml;base64,'+btoa(unescape(encodeURIComponent(rawFile)))+'"';
                //console.log("js encoded");
              }
              if(file.indexOf(".woff") > -1 ){
                readFile = '"data:application/x-font-woff;base64,'+rawFile.toString('base64')+'"';
              }
              if(file.indexOf(".eot") > -1 ){
                readFile = '"data:font/eot;base64,'+rawFile.toString('base64')+'"';
              }
              if(file.indexOf(".ttf") > -1 ){
                readFile = '"data:font/ttf;base64,'+rawFile.toString('base64')+'"';
              }
              
              
              initialData[dir.substring(17)+file]=readFile;
              //console.log(file);
            }
        });
    });
    
    //console.log(pages["index.html"]);
    //console.log(Object.keys(initialData).length);
  }
  readDir(HTMLfolder,true);
  
  function SubCSS(){
    var tostrip ="";
    var urlval = "";
    var trimmedURL = "";
    var found = false;
    var keyz = Object.keys(initialData);
    //console.log("processing css's:"+cssToProcess.length);
    for(var i = 0;i<cssToProcess.length;i++){
      if(!initialData.hasOwnProperty(cssToProcess[i]))continue;
      //console.log("processing:"+cssToProcess[i]);
      tostrip=initialData[cssToProcess[i]];
      var loopbreaker= 100;
      while(tostrip.indexOf("url(")!=-1&&loopbreaker-->0){
        urlval = tostrip.substring(tostrip.indexOf("url(")+4,tostrip.indexOf(")",tostrip.indexOf("url("))).trim();
        trimmedURL = urlval.replace(/\.\.\//g,"").replace(/"/g,"").replace(/#.*/g,"").replace(/'/g,'').replace(/\?.*/g,'').replace(/%40/g,"@").replace(/%20/g," ");
        //console.log(trimmedURL);
        found = false;
        for(var j=0;j<keyz.length;j++){
          if(keyz[j].indexOf(trimmedURL)!=-1)found = keyz[j];
        }
        if(found != false){
          initialData[cssToProcess[i]] = initialData[cssToProcess[i]].substring(0,initialData[cssToProcess[i]].indexOf(urlval))+initialData[found]+initialData[cssToProcess[i]].substring(initialData[cssToProcess[i]].indexOf(urlval)+urlval.length);
          console.log("found:"+trimmedURL);
        }else{
          console.log("NOT found:"+trimmedURL);
        }
        //if(initialData.hasOwnProperty(trimmedURL))console.log("found");else console.log("not found:"+trimmedURL);
        //
        tostrip = tostrip.substr(0,tostrip.indexOf("url("))+tostrip.substr(tostrip.indexOf(")",tostrip.indexOf("url(")));
      }
      if(loopbreaker<2)console.log("loopBroken");
    }
    cssToProcess = [];
  }
  
  
  //buildHeaders();
  var loadedval = false;
  setInterval(function() {
    if(!loadedval){
      if(Object.keys(initialData).length>309){
        //buildHeaders();
        loadedval = true;
      }
    }
  }, 1000);
  var afterten =  setInterval(function() {
    SubCSS();
    console.log("cleaning css's");
    var keyz = Object.keys(initialData);
    for(var j=0;j<keyz.length;j++){
      if(keyz[j].indexOf(".css")!=-1 && initialData[keyz[j]].indexOf("css;base64")==-1){
        console.log("cleaned css:"+keyz[j]);
        console.log(initialData[keyz[j]].indexOf("base64"));
        initialData[keyz[j]] = '"data:text/css;base64,'+btoa(unescape(encodeURIComponent(initialData[keyz[j]])))+'"';
        //console.log(initialData[keyz[j]]);
      }
    }
    clearInterval(afterten);
  }, 10000);
  
  function atob2(str) {
    return new Buffer(str, 'base64').toString('utf8');
  }

  if (this.mountpath instanceof Array) {
    throw new Error("This app can only be mounted on a single path");
  }

  var path = this.mountpath;
  var path = path + (path[path.length - 1] != '/' ? '/' : '') + 'peerjs';

  // Create WebSocket server as well.
  this._wss = new WebSocketServer({ path: path, server: server});

  this._wss.on('connection', function(socket) {
    var query = url.parse(socket.upgradeReq.url, true).query;
    var id = query.id;
    var token = query.token;
    var key = query.key;
    var ip = socket.upgradeReq.socket.remoteAddress;

    if (!id || !token || !key) {
      socket.send(JSON.stringify({ type: 'ERROR', payload: { msg: 'No id, token, or key supplied to websocket server' } }));
      socket.close();
      console.log("socket closed due to token error");
      return;
    }
    if (!self._clients[key] || !self._clients[key][id]) {
      self._checkKey(key, ip, function(err) {
        if (!err) {
          if (!self._clients[key][id]) {
            self._clients[key][id] = { token: token, ip: ip };
            self._ips[ip]++;
            socket.send(JSON.stringify({ type: 'OPEN' }));
          }
          self._configureWS(socket, key, id, token);
        } else {
          socket.send(JSON.stringify({ type: 'ERROR', payload: { msg: err } }));
        }
      });
    } else {
      self._configureWS(socket, key, id, token);
    }
  });
};

app._configureWS = function(socket, key, id, token) {

  var self = this;
  var client = this._clients[key][id];
  if (token === client.token) {
    // res 'close' event will delete client.res for us
    client.socket = socket;
    // Client already exists
    if (client.res) {
      client.res.end();
    }
  } else {
    // ID-taken, invalid token
    socket.send(JSON.stringify({ type: 'ID-TAKEN', payload: { msg: 'ID is taken' } }));
    socket.close();
    console.log("socket closed due to ID error");
    return;
  }

  this._processOutstanding(key, id);

  // Cleanup after a socket closes.
  socket.on('close', function() {
    self._log('Socket closed:', id);
    if (client.socket == socket) {
      self._removePeer(key, id);
    }
    console.log("socket closed ");
  });

  // Handle messages from peers.
  socket.on('message', function(data) {
    try {
      var message = JSON.parse(data);
      if(message.type=="SM"){
        if(message.data.trim() =="heatbeat")return;
        console.log("Received server message:"+message.data.substring(1));
        var requestedPage = message.data.substring(1);//.replace(/\.[^/.]+$/, "");
        if(!pages.hasOwnProperty(requestedPage)){ //if we cant find taht page then just send off the homepage or a 404 page?
          console.log("page not found:"+requestedPage);
          requestedPage = pages.hasOwnProperty("404.html")?"404.html":"index.html";
        }
        if(!Swarms.hasOwnProperty(requestedPage))Swarms[requestedPage]={members:[],page:requestedPage};
        Swarms[requestedPage].members[Swarms[requestedPage].members.length]=id;
        var ips = get5rand(Swarms[requestedPage].members);
        //console.log("ending");
        if(Swarms[requestedPage].members.length>150){//swarm is full so dump this swarm and create a new one
          Swarms[Swarms.length]=Swarms[requestedPage];
          delete Swarms[requestedPage];
        }
        if(ips[0]==0||ips[1]==0||ips[2]==0||ips[3]==0||ips[4]==0||ips[0]==""||ips[1]==""||ips[2]==""||ips[3]==""||ips[4]=="" || message.data.charAt(0)!="@"){//if the swarm has upto 5 users then give each user a copy of the site
              console.log("sending initial data:"+pages[requestedPage].length);
              //var keyz = Object.keys(initialData);
              //console.log("sending page:"+requestedPage);
              //var bt = (new Date()).getTime();
              //first send of the page html data
          socket.send(JSON.stringify({ type: 'SM', payload: { msg: 'Initial Data', name: requestedPage, data: initialData[requestedPage] } }));
          for(var i = 0;i<pages[requestedPage].length;i++){
            //console.log("sending off:"+pages[requestedPage][i]);
            socket.send(JSON.stringify({ type: 'SM', payload: { msg: 'Initial Data', name: pages[requestedPage][i], data: initialData[pages[requestedPage][i]] } }));
          }
        }
        socket.send(JSON.stringify({ type: 'SM', payload: { msg: 'Swarm Details', data: requestedPage+":"+ips.join(":")} })); //send off the swarm details
        console.log("User Logged In:"+id);
        return;
      }
      if (['LEAVE', 'CANDIDATE', 'OFFER', 'ANSWER'].indexOf(message.type) !== -1) {
	      self._handleTransmission(key, {
          type: message.type,
          src: id,
          dst: message.dst,
          payload: message.payload
        });
      } else {
        	util.prettyError('Message unrecognized:');
      }
    } catch(e) {
      self._log('Invalid message', data);
      console.log("Invalid message:"+data+"\n"+e);
      if(typeof key!='undefined'&& typeof id != 'undefined'){
        //app.hardDelete(key,id);
      }
      //throw e;
    }
  });

  // We're going to emit here, because for XHR we don't *know* when someone
  // disconnects.
  this.emit('connection', id);
};
function lookup() {
  return ++randomI >= randoms.length ? randoms [randomI=0] : randoms [randomI];
}

function get5rand(arr){
  //console.log("starting:"+arr);
  var res = [0,0,0,0,0];
  if(arr.length<=7){
    for(var i=0;i<5;i++)
      res[i]=arr[i]==null?0:arr[i];
    return res;
  }
  var loopbreaker = 100;
  res[0] = arr[Math.ceil(lookup() * arr.length)];
  do {
    res[1] = arr[Math.ceil(lookup() * arr.length)];
  } while (res[1] == res[0] && loopbreaker-->0)
  do {
    res[2] = arr[Math.ceil(lookup() * arr.length)];
  } while (res[2] == res[0]||res[2] == res[1]&& loopbreaker-->0)
  do {
    res[3] = arr[Math.ceil(lookup() * arr.length)];
  } while (res[3] == res[0]||res[3] == res[1]||res[3] == res[2]&& loopbreaker-->0)
  do {
    res[4] = arr[Math.ceil(lookup() * arr.length)];
  } while (res[4] == res[0]||res[4] == res[1]||res[4] == res[2]||res[4]==res[3]&& loopbreaker-->0)
  if(loopbreaker<=0){
    console.log("loop broken");
    console.log(arr);
    return [0,0,0,0,0];
  }
  return res;
}

app._checkAllowsDiscovery = function(key, cb) {
  cb(this._options.allow_discovery);
};

app._checkKey = function(key, ip, cb) {
  //console.log("checking key:"+key);
  if (key == this._options.key||key == this._options.old_key) {
    if (!this._clients[key]) {
      this._clients[key] = {};
    }
    if (!this._outstanding[key]) {
      this._outstanding[key] = {};
    }
    if (!this._ips[ip]) {
      this._ips[ip] = 0;
    }
    // Check concurrent limit
    if (Object.keys(this._clients[key]).length >= this._options.concurrent_limit) {
      cb('Server has reached its concurrent user limit');
      return;
    }
    if (this._ips[ip] >= this._options.ip_limit) {
      cb(ip + ' has reached its concurrent user limit');
      return;
    }
    cb(null);
  } else {
    console.log("bad key on client. should be:"+this._options.key);
    cb('Invalid key provided');
  }
};

/** Initialize HTTP server routes. */
app._initializeHTTP = function() {
  var self = this;

  this.use(cors());

  this.get('/', function(req, res, next) {
    res.send(require('../app.json'));
  });

  // Retrieve guaranteed random ID.
  this.get('/:key/id', function(req, res, next) {
    res.contentType = 'text/html';
    res.send(self._generateClientId(req.params.key));
  });

  // Server sets up HTTP streaming when you get post an ID.
  this.post('/:key/:id/:token/id', function(req, res, next) {
    var id = req.params.id;
    var token = req.params.token;
    var key = req.params.key;
    
    var ip = req.connection.remoteAddress;
    if (!self._clients[key] || !self._clients[key][id]) {
      self._checkKey(key, ip, function(err) {
        if (!err && !self._clients[key][id]) {
          self._clients[key][id] = { token: token, ip: ip };
          self._ips[ip]++;
          self._startStreaming(res, key, id, token, true);
        } else {
          res.send(JSON.stringify({ type: 'HTTP-ERROR' }));
        }
      });
    } else {
      self._startStreaming(res, key, id, token);
    }
  });

  // Get a list of all peers for a key, enabled by the `allowDiscovery` flag.
  this.get('/:key/peers', function(req, res, next) {
    var key = req.params.key;
    if (self._clients[key]) {
      self._checkAllowsDiscovery(key, function(isAllowed) {
        if (isAllowed) {
          res.send(Object.keys(self._clients[key]));
        } else {
          res.sendStatus(401);
        }
      });
    } else {
      res.sendStatus(404);
    }
  });

  var handle = function(req, res, next) {
    var key = req.params.key;
    var id = req.params.id;
    var client;
    if (!self._clients[key] || !(client = self._clients[key][id])) {
      if (req.params.retry) {
        res.sendStatus(401);
        return;
      } else {
        // Retry this request
        req.params.retry = true;
        setTimeout(handle, 25, req, res);
        return;
      }
    }

    // Auth the req
    if (req.params.token !== client.token) {
      res.sendStatus(401);
      return;
    } else {
      self._handleTransmission(key, {
        type: req.body.type,
        src: id,
        dst: req.body.dst,
        payload: req.body.payload
      });
      res.sendStatus(200);
    }
  };

  var jsonParser = bodyParser.json();

  this.post('/:key/:id/:token/offer', jsonParser, handle);

  this.post('/:key/:id/:token/candidate', jsonParser, handle);

  this.post('/:key/:id/:token/answer', jsonParser, handle);

  this.post('/:key/:id/:token/leave', jsonParser, handle);
};

/** Saves a streaming response and takes care of timeouts and headers. */
app._startStreaming = function(res, key, id, token, open) {
  var self = this;

  res.writeHead(200, {'Content-Type': 'application/octet-stream'});

  var pad = '00';
  for (var i = 0; i < 10; i++) {
    pad += pad;
  }
  res.write(pad + '\n');

  if (open) {
    res.write(JSON.stringify({ type: 'OPEN' }) + '\n');
  }

  var client = this._clients[key][id];

  if (token === client.token) {
    // Client already exists
    res.on('close', function() {
      //console.log("socket closed also");
      if (client.res === res) {
        if (!client.socket) {
          // No new request yet, peer dead
          self._removePeer(key, id);
          return;
        }
        delete client.res;
      }
    });
    client.res = res;
    this._processOutstanding(key, id);
  } else {
    // ID-taken, invalid token
    res.end(JSON.stringify({ type: 'HTTP-ERROR' }));
  }
};

app._generateHash = function (str,num) {
      var hash = 0, i, chr, len;
      if (str.length == 0) return hash;
      if(str.length<8)str = str+"peterpan"+str;
      for (i = 0, len = str.length; i < len; i++) {
        chr   = str.charCodeAt(i);
        hash  = ((hash << 5) - hash) + chr;
        hash |= 0; // Convert to 32bit integer
      }
      return btoa(hash).replace("+","0").replace("=",'1').substring(3,(typeof num=='undefined'?8:num)+3);
    };

app._pruneOutstanding = function() {
  var keys = Object.keys(this._outstanding);
  for (var k = 0, kk = keys.length; k < kk; k += 1) {
    var key = keys[k];
    var dsts = Object.keys(this._outstanding[key]);
    for (var i = 0, ii = dsts.length; i < ii; i += 1) {
      var offers = this._outstanding[key][dsts[i]];
      var seen = {};
      for (var j = 0, jj = offers.length; j < jj; j += 1) {
        var message = offers[j];
        if (!seen[message.src]) {
          this._handleTransmission(key, { type: 'EXPIRE', src: message.dst, dst: message.src });
          seen[message.src] = true;
        }
      }
    }
    this._outstanding[key] = {};
  }
};

/** Cleanup */
app._setCleanupIntervals = function() {
  var self = this;

  // Clean up ips every 30 sec
  setInterval(function() {
    var keys = Object.keys(self._ips);
    for (var i = 0, ii = keys.length; i < ii; i += 1) {
      var key = keys[i];
      if (self._ips[key] === 0) {
        delete self._ips[key];
      }
    }
    //return;
    try{
    if(typeof self._clients['peerjs'] != 'undefined'){
      var Skeys = Object.keys(Swarms);
      for(var j = 0;j<Skeys.length;j++){
        for(var k = Swarms[Skeys[j]].members.length;k>0;k--){
          if(typeof(Swarms[Skeys[j]].members[k])!='undefined')
          if(!self._clients['peerjs'].hasOwnProperty(Swarms[Skeys[j]].members[k])){//user has left the swarm 
            console.log("removing:"+Swarms[Skeys[j]].members[k]);
            console.log(Object.keys(self._clients['peerjs'] ));
            Swarms[Skeys[j]].members= Swarms[Skeys[j]].members.splice(k,1);
          }
        }
      }
      console.log("checking swarms");
      for(var l=Swarms.length;l>0;l--){
        if(Swarms[l]!=null){
          if(Swarms[l].members!=null){
            if(Swarms[l].members.length==0){
              console.log("Deleting Swarm for page"+Swarms[l].page);
              Swarms = Swarms.splice(i,1);
            }
          }
        }
      }
    }
    }catch(e){
      console.log("Error cleaning out swarms:"+e.stack);
    }
    
  }, 30000);

  // Clean up outstanding messages every 5 seconds
  setInterval(function() {
    self._pruneOutstanding();
  }, 5000);
};

/** Process outstanding peer offers. */
app._processOutstanding = function(key, id) {
  var offers = this._outstanding[key][id];
  if (!offers) {
    return;
  }
  for (var j = 0, jj = offers.length; j < jj; j += 1) {
    this._handleTransmission(key, offers[j]);
  }
  delete this._outstanding[key][id];
};

app._removePeer = function(key, id) {
  if (this._clients[key] && this._clients[key][id]) {
    this._ips[this._clients[key][id].ip]--;
    delete this._clients[key][id];
    this.emit('disconnect', id);
  }
};

/** Handles passing on a message. */
app._handleTransmission = function(key, message) {
  var type = message.type;
  var src = message.src;
  var dst = message.dst;
  var data = JSON.stringify(message);

  var destination = this._clients[key][dst];

  // User is connected!
  if (destination) {
    try {
      this._log(type, 'from', src, 'to', dst);
      if (destination.socket) {
        destination.socket.send(data);
      } else if (destination.res) {
        data += '\n';
        destination.res.write(data);
      } else {
        // Neither socket no res available. Peer dead?
        throw "Peer dead";
      }
    } catch (e) {
      // This happens when a peer disconnects without closing connections and
      // the associated WebSocket has not closed.
      // Tell other side to stop trying.
      this._removePeer(key, dst);
      this._handleTransmission(key, {
        type: 'LEAVE',
        src: dst,
        dst: src
      });
    }
  } else {
    // Wait for this client to connect/reconnect (XHR) for important
    // messages.
    if (type !== 'LEAVE' && type !== 'EXPIRE' && dst) {
      var self = this;
      if (!this._outstanding[key][dst]) {
        this._outstanding[key][dst] = [];
      }
      this._outstanding[key][dst].push(message);
    } else if (type === 'LEAVE' && !dst) {
      this._removePeer(key, src);
    } else {
      // Unavailable destination specified with message LEAVE or EXPIRE
      // Ignore
    }
  }
};

app._generateClientId = function(key) {
  var clientId = util.randomId();
  if (!this._clients[key]) {
    return clientId;
  }
  while (!!this._clients[key][clientId]) {
    clientId = util.randomId();
  }
  return clientId;
};

app._log = function() {
  if (this._options.debug) {
    console.log.apply(console, arguments);
  }
};
